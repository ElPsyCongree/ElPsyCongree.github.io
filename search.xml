<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇编调用指令，堆栈操作详解</title>
      <link href="/2019/09/27/base-asm-calls/"/>
      <url>/2019/09/27/base-asm-calls/</url>
      
        <content type="html"><![CDATA[<h2 id="一些常用的汇编指令直观翻译"><a href="#一些常用的汇编指令直观翻译" class="headerlink" title="一些常用的汇编指令直观翻译"></a>一些常用的汇编指令直观翻译</h2><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , <span class="hljs-built_in">ebx</span>            <span class="hljs-comment">; eax = ebx</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">ebx</span> + <span class="hljs-number">30</span>]     <span class="hljs-comment">; eax = ebx + 30 </span><br>                         <span class="hljs-comment">; 不这样写就是两条指令 mov eax, ebx ;add eax 30</span><br><span class="hljs-keyword">push</span> <span class="hljs-keyword">pop</span>                 <span class="hljs-comment">; 入栈，出栈</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span>               <span class="hljs-comment">; eax += 5</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span>               <span class="hljs-comment">; eax -= 5</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span>                  <span class="hljs-comment">; eax += 1</span><br><span class="hljs-keyword">mul</span>                      <span class="hljs-comment">; 乘法</span><br><span class="hljs-keyword">div</span>                      <span class="hljs-comment">; 除法</span><br></code></pre></td></tr></table></figure><h2 id="改变堆栈的操作"><a href="#改变堆栈的操作" class="headerlink" title="改变堆栈的操作"></a>改变堆栈的操作</h2><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>   // <span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span>  <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>] , <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span>    // <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">esp</span>]   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span><br><span class="hljs-keyword">call</span> <span class="hljs-number">1234</span>  // <span class="hljs-keyword">push</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">jmp</span> <span class="hljs-number">1234</span><br><span class="hljs-keyword">retn</span> <span class="hljs-number">8</span>     // <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">8</span>   常用于 __stdcall,这种函数自己清理自己的参数的<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , xxx<br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , xxx<br></code></pre></td></tr></table></figure><a id="more"></a><h2 id="栈指针、帧指针的学习"><a href="#栈指针、帧指针的学习" class="headerlink" title="栈指针、帧指针的学习"></a>栈指针、帧指针的学习</h2><p>ESP栈指针,每一次push或者pop值会跟这变，永远指向栈顶 <br><br>EBP帧指针，其实有无无所谓，如果没有使用ESP取局部变量和参数的时候因为地址会一直改变，人的理解上比较麻烦，于是在call指令save 的 EIP后记录下来当前的ESP到EBP中，这样子取参数或者局部变量的时候回更方便。<br></p><p>以下面这个在32位x86计算机上编译的函数为例：</p><figure class="hljs highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span></span>; <span class="hljs-comment">// a function to call</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo_stackframe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, in c)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-keyword">int</span> z;<br>    bar(z, y);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="../../images/only_esp.png" alt="&quot;&quot;"></p><p>调用bar函数的时候,如果没有设置 ebp传递参数汇编码如下:</p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; 假设为__cdecl,参数从右往左入栈，调用者清理堆栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>]    <span class="hljs-comment">; push y</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>]    <span class="hljs-comment">; push z</span><br><span class="hljs-keyword">call</span> bar              <span class="hljs-comment">; push eip,jmp bar</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span>            <span class="hljs-comment">; 清理堆栈</span><br></code></pre></td></tr></table></figure><p>我们可以发现，如果根据esp来寻找地址，很不直观，第一次我们将 y push到堆栈中后，导致esp sub 4,然后取z的时候地址就会跟着改变，显然这样理解上比较麻烦，同一个参数获取的时候esp的偏移量总是不一样。</p><p>为了更好的计算偏移量，我们需要一个固定不变的堆栈地址，这样就不会出现同一个参数然后偏移不一样的情况。于是引入了ebp(帧指针)的概念,在call bar之后将esp地址记录下来，此时的堆栈情况如下。</p><p><img src="../../images/use_ebp.png" alt="&quot;&quot;"><br>注意调用前要把caller的ebp保存起来，不然到调用完成后，caller的ebp就找不到了。所以调用bar函数前要写上“序言”代码</p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span>        <span class="hljs-comment">; 保存 caller的 ebp </span><br><span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span>   <span class="hljs-comment">; 将bar函数的ebp设置为当前的esp</span><br><span class="hljs-keyword">sub</span>  <span class="hljs-built_in">esp</span>, <span class="hljs-number">76</span>    <span class="hljs-comment">; 提前扩容好局部变量</span><br></code></pre></td></tr></table></figure><p>注意这里仅仅保存了caller函数的ebp,如果想要保存caller函数的其他寄存器信息比如eax之类的，需要在序言这边push进去</p><p>现在调用bar函数的汇编指令差不多为：</p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">72</span>]         <span class="hljs-comment">; push y</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">76</span>]         <span class="hljs-comment">; push z</span><br><span class="hljs-keyword">call</span> bar<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span>                  <span class="hljs-comment">; 清栈</span><br></code></pre></td></tr></table></figure><p>使用了帧指针ebp后，所有的变量相对于ebp的偏移量都可以计算出来。许多时候，正偏移量用于访问函数参数，而负偏移量用于访问局部变量。使用ebp指针后，我们可以自由的更改esp指针而不用担心，其他变量的偏移地址</p><p>最后完成bar函数调用的时候bar：</p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,<span class="hljs-built_in">ebp</span>          <span class="hljs-comment">; 清理局部变量</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span>              <span class="hljs-comment">; 恢复caller函数的ebp</span><br><span class="hljs-keyword">ret</span>                  <span class="hljs-comment">; pop eip</span><br></code></pre></td></tr></table></figure><p>由于 这种操作非常常见，因此x86体系提供了leave指令来缩短汇编指令长度</p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">leave</span>                <span class="hljs-comment">; 相当于</span><br>                     <span class="hljs-comment">; mov esp,ebp</span><br>                     <span class="hljs-comment">; pop ebp</span><br><br><span class="hljs-keyword">ret</span>                  <span class="hljs-comment">; pop eip</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Unity 符号表上传</title>
      <link href="/2019/09/23/bugly-symbol/"/>
      <url>/2019/09/23/bugly-symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-do-it"><a href="#Why-do-it" class="headerlink" title="Why do it"></a>Why do it</h2><p>最近游戏内测，发现不少崩溃的堆栈发生在libunity.so之中，而大部分仅仅给一个代码执行到的PC地址，查起来代码比较蛋疼。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#">#00 pc 00a6ac38 /data/app/.../libunity.so<br>#01 pc 00a6c128 /data/app/.../x86/libunity.so<br>#02 pc 003f1bf6 /data/app/.../x86/libunity.so <br>#03 pc 003f0b4a /data/app/.../x86/libunity.so <br>#04 pc 0039ff68 /data/app/.../x86/libunity.so <br>#05 pc 00396e77 /data/app/.../x86/libunity.so <br>#06 pc 00398ce0 /data/app/.../x86/libunity.so <br>#07 pc 00398149 /data/app/.../x86/libunity.so <br>#08 pc 003980a2 /data/app/.../x86/libunity.so <br>#09 pc 004f2ca3 /data/app/.../x86/libunity.so<br></code></pre></td></tr></table></figure><a id="more"></a><p>这种一般没有符号表，不过我们可以使用addr2line这个经典的binutils工具将PC地址转换为函数名</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./i686-linux-android-addr2line.exe -C -i -f -e libunity.sym.so 00a6ac38<br></code></pre></td></tr></table></figure><p>输出结果如下:<br></p><figure class="hljs highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>)<br></code></pre></td></tr></table></figure><p>我们很快就可以定位到是一个动画状态机的问题，不过问题也接踵而至,BUG量有点多，然后一起看BUGLY的人也不少，客户端的其他人未必懂这些底层知识，那么其实就可以利用Bugly的符号表功能来做这件事情。</p><h2 id="How-to-do"><a href="#How-to-do" class="headerlink" title="How to do"></a>How to do</h2><p>首先去<a href="https://bugly.qq.com/v2/sdkDownload" target="_blank" rel="noopener">Bugly官网</a>上下载最新的符号表导出工具</p><p>Android Unity的符号表路径在Editor\Data\PlaybackEngines\AndroidPlayer\Variations</p><p>搜索libunity.sym.so即可,注意MONO和IL2CPP要对应上传,输入导出和上传指令</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar buglySymbolAndroid.jar -i libunity.sym.so -u -id <span class="hljs-variable">$yourappid</span> -key <span class="hljs-variable">$yourappkey</span> -package <span class="hljs-variable">$packagename</span> -version xx.xx.xx<br></code></pre></td></tr></table></figure><p>在BUGLY界面中打开界面，如果看到对应的符号表已上传就说明成功了<br><br><img src="../../images/symbol_success.png" alt="成功截图"><br><br>报错堆栈变成</p><figure class="hljs highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">#<span class="hljs-number">00</span> pc <span class="hljs-number">00</span>a6ac38 libunity.so mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>) [x86]<br>#<span class="hljs-number">01</span> pc <span class="hljs-number">00</span>a6c128 libunity.so mecanim::statemachine::SetStateMachineInInitialState(mecanim::statemachine::StateMachineConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateMachineWorkspace&amp;) [x86]<br>#<span class="hljs-number">02</span> pc <span class="hljs-number">003f</span>1bf6 libunity.so AnimatorControllerPlayable::GenerateGraph() [x86]<br>#<span class="hljs-number">03</span> pc <span class="hljs-number">003f</span>0b4a libunity.so AnimatorControllerPlayable::SetAnimatorController(RuntimeAnimatorController*) [x86]<br>#<span class="hljs-number">04</span> pc <span class="hljs-number">0039f</span>f68 libunity.so Animator::CreateInternalControllerPlayable() [x86]<br>#<span class="hljs-number">05</span> pc <span class="hljs-number">00396e77</span> libunity.so Animator::CreateObject() [x86]<br>#<span class="hljs-number">06</span> pc <span class="hljs-number">00398</span>ce0 libunity.so Animator::Prepare() [x86]<br></code></pre></td></tr></table></figure><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>将Addr2Line与IDA结合，定位报错汇编码</p>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugly </tag>
            
            <tag> libunity.sym.so </tag>
            
            <tag> 符号表还原 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
