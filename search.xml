<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汇编基本指令复习，以及逆向中如何跟esp ,ebp参数</title>
      <link href="/2019/09/27/%E6%B1%87%E7%BC%96%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E5%A4%8D%E4%B9%A0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%80%86%E5%90%91%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B7%9Fesp-ebp%E5%8F%82%E6%95%B0/"/>
      <url>/2019/09/27/%E6%B1%87%E7%BC%96%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E5%A4%8D%E4%B9%A0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%80%86%E5%90%91%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B7%9Fesp-ebp%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一些常用的汇编指令直观翻译"><a href="#一些常用的汇编指令直观翻译" class="headerlink" title="一些常用的汇编指令直观翻译"></a>一些常用的汇编指令直观翻译</h2><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , <span class="hljs-built_in">ebx</span>   // <span class="hljs-built_in">eax</span> = <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">ebx</span> + <span class="hljs-number">30</span>] // <span class="hljs-built_in">eax</span> = <span class="hljs-built_in">ebx</span> + <span class="hljs-number">30</span><br><span class="hljs-keyword">push</span> <span class="hljs-keyword">pop</span>  //入栈，出栈<br>pushax popax //全部入栈，全部出栈<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">5</span> // <span class="hljs-built_in">eax</span> += <span class="hljs-number">5</span><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">5</span> //<span class="hljs-built_in">eax</span> -= <span class="hljs-number">6</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span>  // <span class="hljs-built_in">eax</span> += <span class="hljs-number">1</span><br><span class="hljs-keyword">mul</span>  //乘法<br><span class="hljs-keyword">div</span>  //除法<br></code></pre></td></tr></table></figure><h2 id="堆栈学习"><a href="#堆栈学习" class="headerlink" title="堆栈学习"></a>堆栈学习</h2><p>ESP   栈顶指针 <br><br>EBP栈底指针 (本层CALL的栈底)<br><br>注意栈的地址是越push越小的<br></p><a id="more"></a><h2 id="改变堆栈的操作"><a href="#改变堆栈的操作" class="headerlink" title="改变堆栈的操作"></a>改变堆栈的操作</h2><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>   // <span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span>  <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>] , <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span>    // <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">esp</span>]   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">4</span><br><span class="hljs-keyword">call</span> <span class="hljs-number">1234</span>  // <span class="hljs-keyword">push</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">jmp</span> <span class="hljs-number">1234</span><br><span class="hljs-keyword">retn</span> <span class="hljs-number">8</span>     // <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">8</span>   <span class="hljs-built_in">eip</span>表示下步要执行的地址<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span> , xxx<br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , xxx<br></code></pre></td></tr></table></figure><h2 id="栈底指针的学习"><a href="#栈底指针的学习" class="headerlink" title="栈底指针的学习"></a>栈底指针的学习</h2><p>在逆向过程中，如果遇到 </p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span> , [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>这样的如何去跟</p><p>这样的就需要把<code>[ebp+8]</code>看成一个整体来处理</p><p>跟进CALL里面看，可以看到这样的代码</p><figure class="hljs highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span>  //在栈中保存 栈顶的指针  (就是返回到xxx的上一个栈元素)<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span> , <span class="hljs-built_in">esp</span>   <br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span> , <span class="hljs-number">10</span><br>...<br>...<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span> , <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br></code></pre></td></tr></table></figure><p>如下这样的格式</p><p>|<br>-|<br>本层的临时参数2|<br>本层的临时参数1|<br>ebp保存的当前栈底的值|<br>返回到上一层的call xxxxx|<br>参数1|<br>参数2|<br>参数3|<br>参数4|<br>|<br>(注意：越往下地址越小)</p><p>可以看出来，ebp + 4 保存的是上层call的地址<br><br>[ebp + 8] 是参数1 <br><br>同理，类推。<br></p><p>ESP寄存器分析：</p><p>在游戏逆向中，如何遇到<br>mov ecx , [esp + 20] //栈顶指针 + 偏移的格式</p><p>首先要确定[esp + 20]是局部变量，还是参数</p><p>那么如何确定呢？</p><p>有下面两个办法</p><p>1.通过手工的算在本层CALL中的堆栈的偏移，然后得到 [esp + 20]的具体位置<br><br>2.查看距离当前堆栈esp的位置，（注意esp越push值越小）<br><br>如果正好20在上层call的函数下面，那么就是上层call的参数<br><br>如何在上层call的上面，那么就是局部变量，就需要在call内部进行分析了</p>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Unity 符号表上传</title>
      <link href="/2019/09/23/bugly-symbol/"/>
      <url>/2019/09/23/bugly-symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-do-it"><a href="#Why-do-it" class="headerlink" title="Why do it"></a>Why do it</h2><p>最近游戏内测，发现不少崩溃的堆栈发生在libunity.so之中，而大部分仅仅给一个代码执行到的PC地址，查起来代码比较蛋疼。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#">#00 pc 00a6ac38 /data/app/.../libunity.so<br>#01 pc 00a6c128 /data/app/.../x86/libunity.so<br>#02 pc 003f1bf6 /data/app/.../x86/libunity.so <br>#03 pc 003f0b4a /data/app/.../x86/libunity.so <br>#04 pc 0039ff68 /data/app/.../x86/libunity.so <br>#05 pc 00396e77 /data/app/.../x86/libunity.so <br>#06 pc 00398ce0 /data/app/.../x86/libunity.so <br>#07 pc 00398149 /data/app/.../x86/libunity.so <br>#08 pc 003980a2 /data/app/.../x86/libunity.so <br>#09 pc 004f2ca3 /data/app/.../x86/libunity.so<br></code></pre></td></tr></table></figure><a id="more"></a><p>这种一般没有符号表，不过我们可以使用addr2line这个经典的binutils工具将PC地址转换为函数名</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./i686-linux-android-addr2line.exe -C -i -f -e libunity.sym.so 00a6ac38<br></code></pre></td></tr></table></figure><p>输出结果如下:<br></p><figure class="hljs highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>)<br></code></pre></td></tr></table></figure><p>我们很快就可以定位到是一个动画状态机的问题，不过问题也接踵而至,BUG量有点多，然后一起看BUGLY的人也不少，客户端的其他人未必懂这些底层知识，那么其实就可以利用Bugly的符号表功能来做这件事情。</p><h2 id="How-to-do"><a href="#How-to-do" class="headerlink" title="How to do"></a>How to do</h2><p>首先去<a href="https://bugly.qq.com/v2/sdkDownload" target="_blank" rel="noopener">Bugly官网</a>上下载最新的符号表导出工具</p><p>Android Unity的符号表路径在Editor\Data\PlaybackEngines\AndroidPlayer\Variations</p><p>搜索libunity.sym.so即可,注意MONO和IL2CPP要对应上传,输入导出和上传指令</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar buglySymbolAndroid.jar -i libunity.sym.so -u -id <span class="hljs-variable">$yourappid</span> -key <span class="hljs-variable">$yourappkey</span> -package <span class="hljs-variable">$packagename</span> -version xx.xx.xx<br></code></pre></td></tr></table></figure><p>在BUGLY界面中打开界面，如果看到对应的符号表已上传就说明成功了<br><br><img src="../../images/symbol_success.png" alt="成功截图"><br><br>报错堆栈变成</p><figure class="hljs highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">#<span class="hljs-number">00</span> pc <span class="hljs-number">00</span>a6ac38 libunity.so mecanim::statemachine::EvaluateState(mecanim::ValueArrayConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateOutput&amp;, mecanim::statemachine::StateWorkspace&amp;, <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>) [x86]<br>#<span class="hljs-number">01</span> pc <span class="hljs-number">00</span>a6c128 libunity.so mecanim::statemachine::SetStateMachineInInitialState(mecanim::statemachine::StateMachineConstant <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineInput <span class="hljs-keyword">const</span>&amp;, mecanim::statemachine::StateMachineOutput&amp;, mecanim::statemachine::StateMachineMemory&amp;, mecanim::statemachine::StateMachineWorkspace&amp;) [x86]<br>#<span class="hljs-number">02</span> pc <span class="hljs-number">003f</span>1bf6 libunity.so AnimatorControllerPlayable::GenerateGraph() [x86]<br>#<span class="hljs-number">03</span> pc <span class="hljs-number">003f</span>0b4a libunity.so AnimatorControllerPlayable::SetAnimatorController(RuntimeAnimatorController*) [x86]<br>#<span class="hljs-number">04</span> pc <span class="hljs-number">0039f</span>f68 libunity.so Animator::CreateInternalControllerPlayable() [x86]<br>#<span class="hljs-number">05</span> pc <span class="hljs-number">00396e77</span> libunity.so Animator::CreateObject() [x86]<br>#<span class="hljs-number">06</span> pc <span class="hljs-number">00398</span>ce0 libunity.so Animator::Prepare() [x86]<br></code></pre></td></tr></table></figure><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>将Addr2Line与IDA结合，定位报错汇编码</p>]]></content>
      
      
      <categories>
          
          <category> 汇编逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugly </tag>
            
            <tag> libunity.sym.so </tag>
            
            <tag> 符号表还原 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
